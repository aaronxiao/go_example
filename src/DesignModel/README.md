## 设计模式



### 创建型：

- ​    **simpleFactory**:  简单工厂模式
- ​    **factoryMethod**:  工厂方法模式
- ​    **abstractFactory**:  抽象工厂模式-抽象工厂模式用于生成产品族的工厂，所生成的对象是有关联的
- ​    **builder**:  创建者模式-将一个复杂对象的构建分离成多个简单对象的构建组合
- ​    **protoType**:  原型模式-使对象能复制自身，并且暴露到接口中，使客户端面向接口编程时，不知道接口实际对象的情况下生成新的对象
- ​    **singleton**:  单例模式



### 结构型：

- ​    **facade**:  外观模式-大部分代码使用此接口简化对facade类的访问
- ​    **adapter**:  适配器模式-用于转换一种接口适配另一种接口
- ​    **proxy**:  代理模式-用于延迟处理操作或者在进行实际操作前后进行其它处理
- ​    **composite**:  组合模式-统一对象和对象集，使得使用相同接口使用对象和对象集
- ​    **flyweight**:  享元模式-从对象中剥离出不发生改变且多个实例需要的重复数据，独立出一个享元，使多个对象共享，从而节省内存以及减少对象数量
- ​    **decorator**:  装饰模式-使用对象组合的方式动态改变或增加对象行为
- ​    **bridge**:  桥模式-分离抽象部分和实现部分。使得两部分独立扩展



### 行为型：

- ​    **mediator**:  中介者模式-封装对象之间互交，使依赖变的简单，并且使复杂互交简单化，封装在中介者中
- ​    **observer**:  观察者模式-用于触发联动， 一个对象的改变会触发其它观察者的相关动作，而此对象无需关心连动对象的具体实现
- ​    **command**:  命令模式-本质是把某个对象的方法调用封装到对象中，方便传递、存储、调用
- ​    **iterator**:  迭代器模式-用于使用相同方式送代不同类型集合或者隐藏集合类型的具体实现
- ​    **templateMethod**:  模板方法模式-使用继承机制，把通用步骤和通用方法放到父类中，把具体实现延迟到子类中实现。使得实现符合开闭原则
- ​    **strategy**:  策略模式-定义一系列算法，让这些算法在运行时可以互换，使得分离算法，符合开闭原则
- ​    **state**:  状态模式-用于分离状态和行为  
- ​    **memento**:  备忘录模式-用于保存程序内部状态到外部，又不希望暴露内部状态的情形
- ​    **interpreter**:  解释器模式-定义一套语言文法，并设计该语言解释器，使用户能使用特定文法控制解释器行为。
- ​    **chain**:  职责链模式-用于分离不同职责，并且动态组合相关职责
- ​    **visitor**:  访问者模式-可以给一系列对象透明的添加功能，并且把相关代码封装到一个类中



